/* soapStub.h
   Generated by gSOAP 2.8.51 for service1.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_ns1	"http://websiteman.cnki.net/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20851
# error "GSOAP VERSION 20851 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__base64Binary;	/* service1.h:129 */
class ns1__getFileDetail;	/* service1.h:145 */
class ns1__getFileDetailResponse;	/* service1.h:148 */
class ns1__Exception;	/* service1.h:151 */
class ns1__deleteFileByName;	/* service1.h:154 */
class ns1__deleteFileByNameResponse;	/* service1.h:157 */
class ns1__getFileMessage;	/* service1.h:160 */
class ns1__getFileMessageResponse;	/* service1.h:163 */
class ns1__deleteBucket;	/* service1.h:166 */
class ns1__deleteBucketResponse;	/* service1.h:169 */
class ns1__deleteOneFile;	/* service1.h:172 */
class ns1__deleteOneFileResponse;	/* service1.h:175 */
class ns1__getBucketNames;	/* service1.h:178 */
class ns1__getBucketNamesResponse;	/* service1.h:181 */
class ns1__uploadFile;	/* service1.h:184 */
class ns1__uploadFileResponse;	/* service1.h:187 */
class ns1__deleteFiles;	/* service1.h:190 */
class ns1__deleteFilesResponse;	/* service1.h:193 */
class ns1__downLoadFile;	/* service1.h:196 */
class ns1__downLoadFileResponse;	/* service1.h:199 */
class ns1__doesBucketExists;	/* service1.h:202 */
class ns1__doesBucketExistsResponse;	/* service1.h:205 */
class ns1__deleteBatchFile;	/* service1.h:208 */
class ns1__deleteBatchFileResponse;	/* service1.h:211 */
class ns1__createBucket;	/* service1.h:214 */
class ns1__createBucketResponse;	/* service1.h:217 */
class ns1__doesFileExists;	/* service1.h:220 */
class ns1__doesFileExistsResponse;	/* service1.h:223 */
class ns1__getBucketFileNames;	/* service1.h:226 */
class ns1__getBucketFileNamesResponse;	/* service1.h:229 */
struct __ns1__deleteFiles;	/* service1.h:1153 */
struct __ns1__createBucket;	/* service1.h:1223 */
struct __ns1__deleteBucket;	/* service1.h:1293 */
struct __ns1__doesBucketExists;	/* service1.h:1363 */
struct __ns1__getBucketNames;	/* service1.h:1433 */
struct __ns1__getBucketFileNames;	/* service1.h:1503 */
struct __ns1__doesFileExists;	/* service1.h:1573 */
struct __ns1__getFileMessage;	/* service1.h:1643 */
struct __ns1__getFileDetail;	/* service1.h:1713 */
struct __ns1__deleteOneFile;	/* service1.h:1783 */
struct __ns1__deleteBatchFile;	/* service1.h:1853 */
struct __ns1__deleteFileByName;	/* service1.h:1923 */
struct __ns1__uploadFile;	/* service1.h:1993 */
struct __ns1__downLoadFile;	/* service1.h:2063 */

/* service1.h:129 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (7)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options(), soap() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:145 */
#ifndef SOAP_TYPE_ns1__getFileDetail
#define SOAP_TYPE_ns1__getFileDetail (12)
/* complex XSD type 'ns1:getFileDetail': */
class SOAP_CMAC ns1__getFileDetail {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getFileDetail
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getFileDetail; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getFileDetail, default initialized and not managed by a soap context
        virtual ns1__getFileDetail *soap_alloc(void) const { return SOAP_NEW(ns1__getFileDetail); }
      public:
        /// Constructor with initializations
        ns1__getFileDetail() : arg0(), soap() { }
        virtual ~ns1__getFileDetail() { }
        /// Friend allocator used by soap_new_ns1__getFileDetail(struct soap*, int)
        friend SOAP_FMAC1 ns1__getFileDetail * SOAP_FMAC2 soap_instantiate_ns1__getFileDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:148 */
#ifndef SOAP_TYPE_ns1__getFileDetailResponse
#define SOAP_TYPE_ns1__getFileDetailResponse (13)
/* complex XSD type 'ns1:getFileDetailResponse': */
class SOAP_CMAC ns1__getFileDetailResponse {
      public:
        /// Optional element 'return' of XSD type 'xsd:string'
        char *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getFileDetailResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getFileDetailResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getFileDetailResponse, default initialized and not managed by a soap context
        virtual ns1__getFileDetailResponse *soap_alloc(void) const { return SOAP_NEW(ns1__getFileDetailResponse); }
      public:
        /// Constructor with initializations
        ns1__getFileDetailResponse() : return_(), soap() { }
        virtual ~ns1__getFileDetailResponse() { }
        /// Friend allocator used by soap_new_ns1__getFileDetailResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getFileDetailResponse * SOAP_FMAC2 soap_instantiate_ns1__getFileDetailResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:151 */
#ifndef SOAP_TYPE_ns1__Exception
#define SOAP_TYPE_ns1__Exception (14)
/* complex XSD type 'ns1:Exception': */
class SOAP_CMAC ns1__Exception {
      public:
        /// Optional element 'message' of XSD type 'xsd:string'
        char *message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Exception
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Exception; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Exception, default initialized and not managed by a soap context
        virtual ns1__Exception *soap_alloc(void) const { return SOAP_NEW(ns1__Exception); }
      public:
        /// Constructor with initializations
        ns1__Exception() : message(), soap() { }
        virtual ~ns1__Exception() { }
        /// Friend allocator used by soap_new_ns1__Exception(struct soap*, int)
        friend SOAP_FMAC1 ns1__Exception * SOAP_FMAC2 soap_instantiate_ns1__Exception(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:154 */
#ifndef SOAP_TYPE_ns1__deleteFileByName
#define SOAP_TYPE_ns1__deleteFileByName (15)
/* complex XSD type 'ns1:deleteFileByName': */
class SOAP_CMAC ns1__deleteFileByName {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__deleteFileByName
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__deleteFileByName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__deleteFileByName, default initialized and not managed by a soap context
        virtual ns1__deleteFileByName *soap_alloc(void) const { return SOAP_NEW(ns1__deleteFileByName); }
      public:
        /// Constructor with initializations
        ns1__deleteFileByName() : arg0(), soap() { }
        virtual ~ns1__deleteFileByName() { }
        /// Friend allocator used by soap_new_ns1__deleteFileByName(struct soap*, int)
        friend SOAP_FMAC1 ns1__deleteFileByName * SOAP_FMAC2 soap_instantiate_ns1__deleteFileByName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:157 */
#ifndef SOAP_TYPE_ns1__deleteFileByNameResponse
#define SOAP_TYPE_ns1__deleteFileByNameResponse (16)
/* complex XSD type 'ns1:deleteFileByNameResponse': */
class SOAP_CMAC ns1__deleteFileByNameResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__deleteFileByNameResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__deleteFileByNameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__deleteFileByNameResponse, default initialized and not managed by a soap context
        virtual ns1__deleteFileByNameResponse *soap_alloc(void) const { return SOAP_NEW(ns1__deleteFileByNameResponse); }
      public:
        /// Constructor with initializations
        ns1__deleteFileByNameResponse() : soap() { }
        virtual ~ns1__deleteFileByNameResponse() { }
        /// Friend allocator used by soap_new_ns1__deleteFileByNameResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__deleteFileByNameResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteFileByNameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:160 */
#ifndef SOAP_TYPE_ns1__getFileMessage
#define SOAP_TYPE_ns1__getFileMessage (17)
/* complex XSD type 'ns1:getFileMessage': */
class SOAP_CMAC ns1__getFileMessage {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Optional element 'arg1' of XSD type 'xsd:string'
        char *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getFileMessage
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getFileMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getFileMessage, default initialized and not managed by a soap context
        virtual ns1__getFileMessage *soap_alloc(void) const { return SOAP_NEW(ns1__getFileMessage); }
      public:
        /// Constructor with initializations
        ns1__getFileMessage() : arg0(), arg1(), soap() { }
        virtual ~ns1__getFileMessage() { }
        /// Friend allocator used by soap_new_ns1__getFileMessage(struct soap*, int)
        friend SOAP_FMAC1 ns1__getFileMessage * SOAP_FMAC2 soap_instantiate_ns1__getFileMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:163 */
#ifndef SOAP_TYPE_ns1__getFileMessageResponse
#define SOAP_TYPE_ns1__getFileMessageResponse (18)
/* complex XSD type 'ns1:getFileMessageResponse': */
class SOAP_CMAC ns1__getFileMessageResponse {
      public:
        /// Optional element 'return' of XSD type 'xsd:string'
        char *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getFileMessageResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getFileMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getFileMessageResponse, default initialized and not managed by a soap context
        virtual ns1__getFileMessageResponse *soap_alloc(void) const { return SOAP_NEW(ns1__getFileMessageResponse); }
      public:
        /// Constructor with initializations
        ns1__getFileMessageResponse() : return_(), soap() { }
        virtual ~ns1__getFileMessageResponse() { }
        /// Friend allocator used by soap_new_ns1__getFileMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getFileMessageResponse * SOAP_FMAC2 soap_instantiate_ns1__getFileMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:166 */
#ifndef SOAP_TYPE_ns1__deleteBucket
#define SOAP_TYPE_ns1__deleteBucket (19)
/* complex XSD type 'ns1:deleteBucket': */
class SOAP_CMAC ns1__deleteBucket {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__deleteBucket
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__deleteBucket; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__deleteBucket, default initialized and not managed by a soap context
        virtual ns1__deleteBucket *soap_alloc(void) const { return SOAP_NEW(ns1__deleteBucket); }
      public:
        /// Constructor with initializations
        ns1__deleteBucket() : arg0(), soap() { }
        virtual ~ns1__deleteBucket() { }
        /// Friend allocator used by soap_new_ns1__deleteBucket(struct soap*, int)
        friend SOAP_FMAC1 ns1__deleteBucket * SOAP_FMAC2 soap_instantiate_ns1__deleteBucket(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:169 */
#ifndef SOAP_TYPE_ns1__deleteBucketResponse
#define SOAP_TYPE_ns1__deleteBucketResponse (20)
/* complex XSD type 'ns1:deleteBucketResponse': */
class SOAP_CMAC ns1__deleteBucketResponse {
      public:
        /// Required element 'return' of XSD type 'xsd:boolean'
        bool return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__deleteBucketResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__deleteBucketResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__deleteBucketResponse, default initialized and not managed by a soap context
        virtual ns1__deleteBucketResponse *soap_alloc(void) const { return SOAP_NEW(ns1__deleteBucketResponse); }
      public:
        /// Constructor with initializations
        ns1__deleteBucketResponse() : return_(), soap() { }
        virtual ~ns1__deleteBucketResponse() { }
        /// Friend allocator used by soap_new_ns1__deleteBucketResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__deleteBucketResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteBucketResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:172 */
#ifndef SOAP_TYPE_ns1__deleteOneFile
#define SOAP_TYPE_ns1__deleteOneFile (21)
/* complex XSD type 'ns1:deleteOneFile': */
class SOAP_CMAC ns1__deleteOneFile {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Optional element 'arg1' of XSD type 'xsd:string'
        char *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__deleteOneFile
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__deleteOneFile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__deleteOneFile, default initialized and not managed by a soap context
        virtual ns1__deleteOneFile *soap_alloc(void) const { return SOAP_NEW(ns1__deleteOneFile); }
      public:
        /// Constructor with initializations
        ns1__deleteOneFile() : arg0(), arg1(), soap() { }
        virtual ~ns1__deleteOneFile() { }
        /// Friend allocator used by soap_new_ns1__deleteOneFile(struct soap*, int)
        friend SOAP_FMAC1 ns1__deleteOneFile * SOAP_FMAC2 soap_instantiate_ns1__deleteOneFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:175 */
#ifndef SOAP_TYPE_ns1__deleteOneFileResponse
#define SOAP_TYPE_ns1__deleteOneFileResponse (22)
/* complex XSD type 'ns1:deleteOneFileResponse': */
class SOAP_CMAC ns1__deleteOneFileResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__deleteOneFileResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__deleteOneFileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__deleteOneFileResponse, default initialized and not managed by a soap context
        virtual ns1__deleteOneFileResponse *soap_alloc(void) const { return SOAP_NEW(ns1__deleteOneFileResponse); }
      public:
        /// Constructor with initializations
        ns1__deleteOneFileResponse() : soap() { }
        virtual ~ns1__deleteOneFileResponse() { }
        /// Friend allocator used by soap_new_ns1__deleteOneFileResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__deleteOneFileResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteOneFileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:178 */
#ifndef SOAP_TYPE_ns1__getBucketNames
#define SOAP_TYPE_ns1__getBucketNames (23)
/* complex XSD type 'ns1:getBucketNames': */
class SOAP_CMAC ns1__getBucketNames {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getBucketNames
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getBucketNames; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getBucketNames, default initialized and not managed by a soap context
        virtual ns1__getBucketNames *soap_alloc(void) const { return SOAP_NEW(ns1__getBucketNames); }
      public:
        /// Constructor with initializations
        ns1__getBucketNames() : soap() { }
        virtual ~ns1__getBucketNames() { }
        /// Friend allocator used by soap_new_ns1__getBucketNames(struct soap*, int)
        friend SOAP_FMAC1 ns1__getBucketNames * SOAP_FMAC2 soap_instantiate_ns1__getBucketNames(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:181 */
#ifndef SOAP_TYPE_ns1__getBucketNamesResponse
#define SOAP_TYPE_ns1__getBucketNamesResponse (24)
/* complex XSD type 'ns1:getBucketNamesResponse': */
class SOAP_CMAC ns1__getBucketNamesResponse {
      public:
        /// Sequence of elements 'return' of XSD type 'xsd:string' stored in dynamic array return_ of length __sizereturn_
        int __sizereturn_;
        char **return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getBucketNamesResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getBucketNamesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getBucketNamesResponse, default initialized and not managed by a soap context
        virtual ns1__getBucketNamesResponse *soap_alloc(void) const { return SOAP_NEW(ns1__getBucketNamesResponse); }
      public:
        /// Constructor with initializations
        ns1__getBucketNamesResponse() : __sizereturn_(), return_(), soap() { }
        virtual ~ns1__getBucketNamesResponse() { }
        /// Friend allocator used by soap_new_ns1__getBucketNamesResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getBucketNamesResponse * SOAP_FMAC2 soap_instantiate_ns1__getBucketNamesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:184 */
#ifndef SOAP_TYPE_ns1__uploadFile
#define SOAP_TYPE_ns1__uploadFile (25)
/* complex XSD type 'ns1:uploadFile': */
class SOAP_CMAC ns1__uploadFile {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Optional element 'arg1' of XSD type 'xsd:string'
        char *arg1;
        /// Optional element 'arg2' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *arg2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__uploadFile
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__uploadFile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__uploadFile, default initialized and not managed by a soap context
        virtual ns1__uploadFile *soap_alloc(void) const { return SOAP_NEW(ns1__uploadFile); }
      public:
        /// Constructor with initializations
        ns1__uploadFile() : arg0(), arg1(), arg2(), soap() { }
        virtual ~ns1__uploadFile() { }
        /// Friend allocator used by soap_new_ns1__uploadFile(struct soap*, int)
        friend SOAP_FMAC1 ns1__uploadFile * SOAP_FMAC2 soap_instantiate_ns1__uploadFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:187 */
#ifndef SOAP_TYPE_ns1__uploadFileResponse
#define SOAP_TYPE_ns1__uploadFileResponse (26)
/* complex XSD type 'ns1:uploadFileResponse': */
class SOAP_CMAC ns1__uploadFileResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__uploadFileResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__uploadFileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__uploadFileResponse, default initialized and not managed by a soap context
        virtual ns1__uploadFileResponse *soap_alloc(void) const { return SOAP_NEW(ns1__uploadFileResponse); }
      public:
        /// Constructor with initializations
        ns1__uploadFileResponse() : soap() { }
        virtual ~ns1__uploadFileResponse() { }
        /// Friend allocator used by soap_new_ns1__uploadFileResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__uploadFileResponse * SOAP_FMAC2 soap_instantiate_ns1__uploadFileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:190 */
#ifndef SOAP_TYPE_ns1__deleteFiles
#define SOAP_TYPE_ns1__deleteFiles (27)
/* complex XSD type 'ns1:deleteFiles': */
class SOAP_CMAC ns1__deleteFiles {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Sequence of elements 'arg1' of XSD type 'xsd:string' stored in dynamic array arg1 of length __sizearg1
        int __sizearg1;
        char **arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__deleteFiles
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__deleteFiles; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__deleteFiles, default initialized and not managed by a soap context
        virtual ns1__deleteFiles *soap_alloc(void) const { return SOAP_NEW(ns1__deleteFiles); }
      public:
        /// Constructor with initializations
        ns1__deleteFiles() : arg0(), __sizearg1(), arg1(), soap() { }
        virtual ~ns1__deleteFiles() { }
        /// Friend allocator used by soap_new_ns1__deleteFiles(struct soap*, int)
        friend SOAP_FMAC1 ns1__deleteFiles * SOAP_FMAC2 soap_instantiate_ns1__deleteFiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:193 */
#ifndef SOAP_TYPE_ns1__deleteFilesResponse
#define SOAP_TYPE_ns1__deleteFilesResponse (28)
/* complex XSD type 'ns1:deleteFilesResponse': */
class SOAP_CMAC ns1__deleteFilesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__deleteFilesResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__deleteFilesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__deleteFilesResponse, default initialized and not managed by a soap context
        virtual ns1__deleteFilesResponse *soap_alloc(void) const { return SOAP_NEW(ns1__deleteFilesResponse); }
      public:
        /// Constructor with initializations
        ns1__deleteFilesResponse() : soap() { }
        virtual ~ns1__deleteFilesResponse() { }
        /// Friend allocator used by soap_new_ns1__deleteFilesResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__deleteFilesResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteFilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:196 */
#ifndef SOAP_TYPE_ns1__downLoadFile
#define SOAP_TYPE_ns1__downLoadFile (29)
/* complex XSD type 'ns1:downLoadFile': */
class SOAP_CMAC ns1__downLoadFile {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Optional element 'arg1' of XSD type 'xsd:string'
        char *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__downLoadFile
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__downLoadFile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__downLoadFile, default initialized and not managed by a soap context
        virtual ns1__downLoadFile *soap_alloc(void) const { return SOAP_NEW(ns1__downLoadFile); }
      public:
        /// Constructor with initializations
        ns1__downLoadFile() : arg0(), arg1(), soap() { }
        virtual ~ns1__downLoadFile() { }
        /// Friend allocator used by soap_new_ns1__downLoadFile(struct soap*, int)
        friend SOAP_FMAC1 ns1__downLoadFile * SOAP_FMAC2 soap_instantiate_ns1__downLoadFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:199 */
#ifndef SOAP_TYPE_ns1__downLoadFileResponse
#define SOAP_TYPE_ns1__downLoadFileResponse (30)
/* complex XSD type 'ns1:downLoadFileResponse': */
class SOAP_CMAC ns1__downLoadFileResponse {
      public:
        /// Optional element 'return' of XSD type 'xsd:string'
        char *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__downLoadFileResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__downLoadFileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__downLoadFileResponse, default initialized and not managed by a soap context
        virtual ns1__downLoadFileResponse *soap_alloc(void) const { return SOAP_NEW(ns1__downLoadFileResponse); }
      public:
        /// Constructor with initializations
        ns1__downLoadFileResponse() : return_(), soap() { }
        virtual ~ns1__downLoadFileResponse() { }
        /// Friend allocator used by soap_new_ns1__downLoadFileResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__downLoadFileResponse * SOAP_FMAC2 soap_instantiate_ns1__downLoadFileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:202 */
#ifndef SOAP_TYPE_ns1__doesBucketExists
#define SOAP_TYPE_ns1__doesBucketExists (31)
/* complex XSD type 'ns1:doesBucketExists': */
class SOAP_CMAC ns1__doesBucketExists {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__doesBucketExists
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__doesBucketExists; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__doesBucketExists, default initialized and not managed by a soap context
        virtual ns1__doesBucketExists *soap_alloc(void) const { return SOAP_NEW(ns1__doesBucketExists); }
      public:
        /// Constructor with initializations
        ns1__doesBucketExists() : arg0(), soap() { }
        virtual ~ns1__doesBucketExists() { }
        /// Friend allocator used by soap_new_ns1__doesBucketExists(struct soap*, int)
        friend SOAP_FMAC1 ns1__doesBucketExists * SOAP_FMAC2 soap_instantiate_ns1__doesBucketExists(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:205 */
#ifndef SOAP_TYPE_ns1__doesBucketExistsResponse
#define SOAP_TYPE_ns1__doesBucketExistsResponse (32)
/* complex XSD type 'ns1:doesBucketExistsResponse': */
class SOAP_CMAC ns1__doesBucketExistsResponse {
      public:
        /// Required element 'return' of XSD type 'xsd:boolean'
        bool return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__doesBucketExistsResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__doesBucketExistsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__doesBucketExistsResponse, default initialized and not managed by a soap context
        virtual ns1__doesBucketExistsResponse *soap_alloc(void) const { return SOAP_NEW(ns1__doesBucketExistsResponse); }
      public:
        /// Constructor with initializations
        ns1__doesBucketExistsResponse() : return_(), soap() { }
        virtual ~ns1__doesBucketExistsResponse() { }
        /// Friend allocator used by soap_new_ns1__doesBucketExistsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__doesBucketExistsResponse * SOAP_FMAC2 soap_instantiate_ns1__doesBucketExistsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:208 */
#ifndef SOAP_TYPE_ns1__deleteBatchFile
#define SOAP_TYPE_ns1__deleteBatchFile (33)
/* complex XSD type 'ns1:deleteBatchFile': */
class SOAP_CMAC ns1__deleteBatchFile {
      public:
        /// Sequence of elements 'arg0' of XSD type 'xsd:string' stored in dynamic array arg0 of length __sizearg0
        int __sizearg0;
        char **arg0;
        /// Sequence of elements 'arg1' of XSD type 'xsd:string' stored in dynamic array arg1 of length __sizearg1
        int __sizearg1;
        char **arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__deleteBatchFile
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__deleteBatchFile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__deleteBatchFile, default initialized and not managed by a soap context
        virtual ns1__deleteBatchFile *soap_alloc(void) const { return SOAP_NEW(ns1__deleteBatchFile); }
      public:
        /// Constructor with initializations
        ns1__deleteBatchFile() : __sizearg0(), arg0(), __sizearg1(), arg1(), soap() { }
        virtual ~ns1__deleteBatchFile() { }
        /// Friend allocator used by soap_new_ns1__deleteBatchFile(struct soap*, int)
        friend SOAP_FMAC1 ns1__deleteBatchFile * SOAP_FMAC2 soap_instantiate_ns1__deleteBatchFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:211 */
#ifndef SOAP_TYPE_ns1__deleteBatchFileResponse
#define SOAP_TYPE_ns1__deleteBatchFileResponse (34)
/* complex XSD type 'ns1:deleteBatchFileResponse': */
class SOAP_CMAC ns1__deleteBatchFileResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__deleteBatchFileResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__deleteBatchFileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__deleteBatchFileResponse, default initialized and not managed by a soap context
        virtual ns1__deleteBatchFileResponse *soap_alloc(void) const { return SOAP_NEW(ns1__deleteBatchFileResponse); }
      public:
        /// Constructor with initializations
        ns1__deleteBatchFileResponse() : soap() { }
        virtual ~ns1__deleteBatchFileResponse() { }
        /// Friend allocator used by soap_new_ns1__deleteBatchFileResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__deleteBatchFileResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteBatchFileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:214 */
#ifndef SOAP_TYPE_ns1__createBucket
#define SOAP_TYPE_ns1__createBucket (35)
/* complex XSD type 'ns1:createBucket': */
class SOAP_CMAC ns1__createBucket {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__createBucket
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__createBucket; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__createBucket, default initialized and not managed by a soap context
        virtual ns1__createBucket *soap_alloc(void) const { return SOAP_NEW(ns1__createBucket); }
      public:
        /// Constructor with initializations
        ns1__createBucket() : arg0(), soap() { }
        virtual ~ns1__createBucket() { }
        /// Friend allocator used by soap_new_ns1__createBucket(struct soap*, int)
        friend SOAP_FMAC1 ns1__createBucket * SOAP_FMAC2 soap_instantiate_ns1__createBucket(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:217 */
#ifndef SOAP_TYPE_ns1__createBucketResponse
#define SOAP_TYPE_ns1__createBucketResponse (36)
/* complex XSD type 'ns1:createBucketResponse': */
class SOAP_CMAC ns1__createBucketResponse {
      public:
        /// Required element 'return' of XSD type 'xsd:boolean'
        bool return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__createBucketResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__createBucketResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__createBucketResponse, default initialized and not managed by a soap context
        virtual ns1__createBucketResponse *soap_alloc(void) const { return SOAP_NEW(ns1__createBucketResponse); }
      public:
        /// Constructor with initializations
        ns1__createBucketResponse() : return_(), soap() { }
        virtual ~ns1__createBucketResponse() { }
        /// Friend allocator used by soap_new_ns1__createBucketResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__createBucketResponse * SOAP_FMAC2 soap_instantiate_ns1__createBucketResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:220 */
#ifndef SOAP_TYPE_ns1__doesFileExists
#define SOAP_TYPE_ns1__doesFileExists (37)
/* complex XSD type 'ns1:doesFileExists': */
class SOAP_CMAC ns1__doesFileExists {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Optional element 'arg1' of XSD type 'xsd:string'
        char *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__doesFileExists
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__doesFileExists; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__doesFileExists, default initialized and not managed by a soap context
        virtual ns1__doesFileExists *soap_alloc(void) const { return SOAP_NEW(ns1__doesFileExists); }
      public:
        /// Constructor with initializations
        ns1__doesFileExists() : arg0(), arg1(), soap() { }
        virtual ~ns1__doesFileExists() { }
        /// Friend allocator used by soap_new_ns1__doesFileExists(struct soap*, int)
        friend SOAP_FMAC1 ns1__doesFileExists * SOAP_FMAC2 soap_instantiate_ns1__doesFileExists(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:223 */
#ifndef SOAP_TYPE_ns1__doesFileExistsResponse
#define SOAP_TYPE_ns1__doesFileExistsResponse (38)
/* complex XSD type 'ns1:doesFileExistsResponse': */
class SOAP_CMAC ns1__doesFileExistsResponse {
      public:
        /// Required element 'return' of XSD type 'xsd:boolean'
        bool return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__doesFileExistsResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__doesFileExistsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__doesFileExistsResponse, default initialized and not managed by a soap context
        virtual ns1__doesFileExistsResponse *soap_alloc(void) const { return SOAP_NEW(ns1__doesFileExistsResponse); }
      public:
        /// Constructor with initializations
        ns1__doesFileExistsResponse() : return_(), soap() { }
        virtual ~ns1__doesFileExistsResponse() { }
        /// Friend allocator used by soap_new_ns1__doesFileExistsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__doesFileExistsResponse * SOAP_FMAC2 soap_instantiate_ns1__doesFileExistsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:226 */
#ifndef SOAP_TYPE_ns1__getBucketFileNames
#define SOAP_TYPE_ns1__getBucketFileNames (39)
/* complex XSD type 'ns1:getBucketFileNames': */
class SOAP_CMAC ns1__getBucketFileNames {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        char *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getBucketFileNames
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getBucketFileNames; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getBucketFileNames, default initialized and not managed by a soap context
        virtual ns1__getBucketFileNames *soap_alloc(void) const { return SOAP_NEW(ns1__getBucketFileNames); }
      public:
        /// Constructor with initializations
        ns1__getBucketFileNames() : arg0(), soap() { }
        virtual ~ns1__getBucketFileNames() { }
        /// Friend allocator used by soap_new_ns1__getBucketFileNames(struct soap*, int)
        friend SOAP_FMAC1 ns1__getBucketFileNames * SOAP_FMAC2 soap_instantiate_ns1__getBucketFileNames(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:229 */
#ifndef SOAP_TYPE_ns1__getBucketFileNamesResponse
#define SOAP_TYPE_ns1__getBucketFileNamesResponse (40)
/* complex XSD type 'ns1:getBucketFileNamesResponse': */
class SOAP_CMAC ns1__getBucketFileNamesResponse {
      public:
        /// Sequence of elements 'return' of XSD type 'xsd:string' stored in dynamic array return_ of length __sizereturn_
        int __sizereturn_;
        char **return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getBucketFileNamesResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getBucketFileNamesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getBucketFileNamesResponse, default initialized and not managed by a soap context
        virtual ns1__getBucketFileNamesResponse *soap_alloc(void) const { return SOAP_NEW(ns1__getBucketFileNamesResponse); }
      public:
        /// Constructor with initializations
        ns1__getBucketFileNamesResponse() : __sizereturn_(), return_(), soap() { }
        virtual ~ns1__getBucketFileNamesResponse() { }
        /// Friend allocator used by soap_new_ns1__getBucketFileNamesResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getBucketFileNamesResponse * SOAP_FMAC2 soap_instantiate_ns1__getBucketFileNamesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1067 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (44)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        /** Optional element 'ns1:Exception' of XSD type 'ns1:Exception' */
        ns1__Exception *ns1__Exception_;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
        char *__any;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : ns1__Exception_(), __type(), fault(), __any() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* service1.h:1153 */
#ifndef SOAP_TYPE___ns1__deleteFiles
#define SOAP_TYPE___ns1__deleteFiles (51)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteFiles {
      public:
        /** Optional element 'ns1:deleteFiles' of XSD type 'ns1:deleteFiles' */
        ns1__deleteFiles *ns1__deleteFiles_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteFiles */
        int soap_type() const { return SOAP_TYPE___ns1__deleteFiles; }
        /** Constructor with member initializations */
        __ns1__deleteFiles() : ns1__deleteFiles_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteFiles * SOAP_FMAC2 soap_instantiate___ns1__deleteFiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1223 */
#ifndef SOAP_TYPE___ns1__createBucket
#define SOAP_TYPE___ns1__createBucket (55)
/* Wrapper: */
struct SOAP_CMAC __ns1__createBucket {
      public:
        /** Optional element 'ns1:createBucket' of XSD type 'ns1:createBucket' */
        ns1__createBucket *ns1__createBucket_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__createBucket */
        int soap_type() const { return SOAP_TYPE___ns1__createBucket; }
        /** Constructor with member initializations */
        __ns1__createBucket() : ns1__createBucket_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__createBucket * SOAP_FMAC2 soap_instantiate___ns1__createBucket(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1293 */
#ifndef SOAP_TYPE___ns1__deleteBucket
#define SOAP_TYPE___ns1__deleteBucket (59)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteBucket {
      public:
        /** Optional element 'ns1:deleteBucket' of XSD type 'ns1:deleteBucket' */
        ns1__deleteBucket *ns1__deleteBucket_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteBucket */
        int soap_type() const { return SOAP_TYPE___ns1__deleteBucket; }
        /** Constructor with member initializations */
        __ns1__deleteBucket() : ns1__deleteBucket_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteBucket * SOAP_FMAC2 soap_instantiate___ns1__deleteBucket(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1363 */
#ifndef SOAP_TYPE___ns1__doesBucketExists
#define SOAP_TYPE___ns1__doesBucketExists (63)
/* Wrapper: */
struct SOAP_CMAC __ns1__doesBucketExists {
      public:
        /** Optional element 'ns1:doesBucketExists' of XSD type 'ns1:doesBucketExists' */
        ns1__doesBucketExists *ns1__doesBucketExists_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doesBucketExists */
        int soap_type() const { return SOAP_TYPE___ns1__doesBucketExists; }
        /** Constructor with member initializations */
        __ns1__doesBucketExists() : ns1__doesBucketExists_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doesBucketExists * SOAP_FMAC2 soap_instantiate___ns1__doesBucketExists(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1433 */
#ifndef SOAP_TYPE___ns1__getBucketNames
#define SOAP_TYPE___ns1__getBucketNames (67)
/* Wrapper: */
struct SOAP_CMAC __ns1__getBucketNames {
      public:
        /** Optional element 'ns1:getBucketNames' of XSD type 'ns1:getBucketNames' */
        ns1__getBucketNames *ns1__getBucketNames_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getBucketNames */
        int soap_type() const { return SOAP_TYPE___ns1__getBucketNames; }
        /** Constructor with member initializations */
        __ns1__getBucketNames() : ns1__getBucketNames_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getBucketNames * SOAP_FMAC2 soap_instantiate___ns1__getBucketNames(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1503 */
#ifndef SOAP_TYPE___ns1__getBucketFileNames
#define SOAP_TYPE___ns1__getBucketFileNames (71)
/* Wrapper: */
struct SOAP_CMAC __ns1__getBucketFileNames {
      public:
        /** Optional element 'ns1:getBucketFileNames' of XSD type 'ns1:getBucketFileNames' */
        ns1__getBucketFileNames *ns1__getBucketFileNames_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getBucketFileNames */
        int soap_type() const { return SOAP_TYPE___ns1__getBucketFileNames; }
        /** Constructor with member initializations */
        __ns1__getBucketFileNames() : ns1__getBucketFileNames_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getBucketFileNames * SOAP_FMAC2 soap_instantiate___ns1__getBucketFileNames(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1573 */
#ifndef SOAP_TYPE___ns1__doesFileExists
#define SOAP_TYPE___ns1__doesFileExists (75)
/* Wrapper: */
struct SOAP_CMAC __ns1__doesFileExists {
      public:
        /** Optional element 'ns1:doesFileExists' of XSD type 'ns1:doesFileExists' */
        ns1__doesFileExists *ns1__doesFileExists_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__doesFileExists */
        int soap_type() const { return SOAP_TYPE___ns1__doesFileExists; }
        /** Constructor with member initializations */
        __ns1__doesFileExists() : ns1__doesFileExists_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__doesFileExists * SOAP_FMAC2 soap_instantiate___ns1__doesFileExists(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1643 */
#ifndef SOAP_TYPE___ns1__getFileMessage
#define SOAP_TYPE___ns1__getFileMessage (79)
/* Wrapper: */
struct SOAP_CMAC __ns1__getFileMessage {
      public:
        /** Optional element 'ns1:getFileMessage' of XSD type 'ns1:getFileMessage' */
        ns1__getFileMessage *ns1__getFileMessage_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getFileMessage */
        int soap_type() const { return SOAP_TYPE___ns1__getFileMessage; }
        /** Constructor with member initializations */
        __ns1__getFileMessage() : ns1__getFileMessage_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getFileMessage * SOAP_FMAC2 soap_instantiate___ns1__getFileMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1713 */
#ifndef SOAP_TYPE___ns1__getFileDetail
#define SOAP_TYPE___ns1__getFileDetail (83)
/* Wrapper: */
struct SOAP_CMAC __ns1__getFileDetail {
      public:
        /** Optional element 'ns1:getFileDetail' of XSD type 'ns1:getFileDetail' */
        ns1__getFileDetail *ns1__getFileDetail_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getFileDetail */
        int soap_type() const { return SOAP_TYPE___ns1__getFileDetail; }
        /** Constructor with member initializations */
        __ns1__getFileDetail() : ns1__getFileDetail_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getFileDetail * SOAP_FMAC2 soap_instantiate___ns1__getFileDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1783 */
#ifndef SOAP_TYPE___ns1__deleteOneFile
#define SOAP_TYPE___ns1__deleteOneFile (87)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteOneFile {
      public:
        /** Optional element 'ns1:deleteOneFile' of XSD type 'ns1:deleteOneFile' */
        ns1__deleteOneFile *ns1__deleteOneFile_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteOneFile */
        int soap_type() const { return SOAP_TYPE___ns1__deleteOneFile; }
        /** Constructor with member initializations */
        __ns1__deleteOneFile() : ns1__deleteOneFile_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteOneFile * SOAP_FMAC2 soap_instantiate___ns1__deleteOneFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1853 */
#ifndef SOAP_TYPE___ns1__deleteBatchFile
#define SOAP_TYPE___ns1__deleteBatchFile (91)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteBatchFile {
      public:
        /** Optional element 'ns1:deleteBatchFile' of XSD type 'ns1:deleteBatchFile' */
        ns1__deleteBatchFile *ns1__deleteBatchFile_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteBatchFile */
        int soap_type() const { return SOAP_TYPE___ns1__deleteBatchFile; }
        /** Constructor with member initializations */
        __ns1__deleteBatchFile() : ns1__deleteBatchFile_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteBatchFile * SOAP_FMAC2 soap_instantiate___ns1__deleteBatchFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1923 */
#ifndef SOAP_TYPE___ns1__deleteFileByName
#define SOAP_TYPE___ns1__deleteFileByName (95)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteFileByName {
      public:
        /** Optional element 'ns1:deleteFileByName' of XSD type 'ns1:deleteFileByName' */
        ns1__deleteFileByName *ns1__deleteFileByName_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteFileByName */
        int soap_type() const { return SOAP_TYPE___ns1__deleteFileByName; }
        /** Constructor with member initializations */
        __ns1__deleteFileByName() : ns1__deleteFileByName_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteFileByName * SOAP_FMAC2 soap_instantiate___ns1__deleteFileByName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:1993 */
#ifndef SOAP_TYPE___ns1__uploadFile
#define SOAP_TYPE___ns1__uploadFile (99)
/* Wrapper: */
struct SOAP_CMAC __ns1__uploadFile {
      public:
        /** Optional element 'ns1:uploadFile' of XSD type 'ns1:uploadFile' */
        ns1__uploadFile *ns1__uploadFile_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__uploadFile */
        int soap_type() const { return SOAP_TYPE___ns1__uploadFile; }
        /** Constructor with member initializations */
        __ns1__uploadFile() : ns1__uploadFile_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__uploadFile * SOAP_FMAC2 soap_instantiate___ns1__uploadFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:2063 */
#ifndef SOAP_TYPE___ns1__downLoadFile
#define SOAP_TYPE___ns1__downLoadFile (103)
/* Wrapper: */
struct SOAP_CMAC __ns1__downLoadFile {
      public:
        /** Optional element 'ns1:downLoadFile' of XSD type 'ns1:downLoadFile' */
        ns1__downLoadFile *ns1__downLoadFile_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__downLoadFile */
        int soap_type() const { return SOAP_TYPE___ns1__downLoadFile; }
        /** Constructor with member initializations */
        __ns1__downLoadFile() : ns1__downLoadFile_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__downLoadFile * SOAP_FMAC2 soap_instantiate___ns1__downLoadFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* service1.h:2184 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (104)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* service1.h:2184 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (105)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* service1.h:2184 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (107)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* service1.h:2184 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (108)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* service1.h:119 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* service1.h:119 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (9)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (8)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (41)
#endif

/* ns1__getBucketFileNamesResponse has binding name 'ns1__getBucketFileNamesResponse' for type 'ns1:getBucketFileNamesResponse' */
#ifndef SOAP_TYPE_ns1__getBucketFileNamesResponse
#define SOAP_TYPE_ns1__getBucketFileNamesResponse (40)
#endif

/* ns1__getBucketFileNames has binding name 'ns1__getBucketFileNames' for type 'ns1:getBucketFileNames' */
#ifndef SOAP_TYPE_ns1__getBucketFileNames
#define SOAP_TYPE_ns1__getBucketFileNames (39)
#endif

/* ns1__doesFileExistsResponse has binding name 'ns1__doesFileExistsResponse' for type 'ns1:doesFileExistsResponse' */
#ifndef SOAP_TYPE_ns1__doesFileExistsResponse
#define SOAP_TYPE_ns1__doesFileExistsResponse (38)
#endif

/* ns1__doesFileExists has binding name 'ns1__doesFileExists' for type 'ns1:doesFileExists' */
#ifndef SOAP_TYPE_ns1__doesFileExists
#define SOAP_TYPE_ns1__doesFileExists (37)
#endif

/* ns1__createBucketResponse has binding name 'ns1__createBucketResponse' for type 'ns1:createBucketResponse' */
#ifndef SOAP_TYPE_ns1__createBucketResponse
#define SOAP_TYPE_ns1__createBucketResponse (36)
#endif

/* ns1__createBucket has binding name 'ns1__createBucket' for type 'ns1:createBucket' */
#ifndef SOAP_TYPE_ns1__createBucket
#define SOAP_TYPE_ns1__createBucket (35)
#endif

/* ns1__deleteBatchFileResponse has binding name 'ns1__deleteBatchFileResponse' for type 'ns1:deleteBatchFileResponse' */
#ifndef SOAP_TYPE_ns1__deleteBatchFileResponse
#define SOAP_TYPE_ns1__deleteBatchFileResponse (34)
#endif

/* ns1__deleteBatchFile has binding name 'ns1__deleteBatchFile' for type 'ns1:deleteBatchFile' */
#ifndef SOAP_TYPE_ns1__deleteBatchFile
#define SOAP_TYPE_ns1__deleteBatchFile (33)
#endif

/* ns1__doesBucketExistsResponse has binding name 'ns1__doesBucketExistsResponse' for type 'ns1:doesBucketExistsResponse' */
#ifndef SOAP_TYPE_ns1__doesBucketExistsResponse
#define SOAP_TYPE_ns1__doesBucketExistsResponse (32)
#endif

/* ns1__doesBucketExists has binding name 'ns1__doesBucketExists' for type 'ns1:doesBucketExists' */
#ifndef SOAP_TYPE_ns1__doesBucketExists
#define SOAP_TYPE_ns1__doesBucketExists (31)
#endif

/* ns1__downLoadFileResponse has binding name 'ns1__downLoadFileResponse' for type 'ns1:downLoadFileResponse' */
#ifndef SOAP_TYPE_ns1__downLoadFileResponse
#define SOAP_TYPE_ns1__downLoadFileResponse (30)
#endif

/* ns1__downLoadFile has binding name 'ns1__downLoadFile' for type 'ns1:downLoadFile' */
#ifndef SOAP_TYPE_ns1__downLoadFile
#define SOAP_TYPE_ns1__downLoadFile (29)
#endif

/* ns1__deleteFilesResponse has binding name 'ns1__deleteFilesResponse' for type 'ns1:deleteFilesResponse' */
#ifndef SOAP_TYPE_ns1__deleteFilesResponse
#define SOAP_TYPE_ns1__deleteFilesResponse (28)
#endif

/* ns1__deleteFiles has binding name 'ns1__deleteFiles' for type 'ns1:deleteFiles' */
#ifndef SOAP_TYPE_ns1__deleteFiles
#define SOAP_TYPE_ns1__deleteFiles (27)
#endif

/* ns1__uploadFileResponse has binding name 'ns1__uploadFileResponse' for type 'ns1:uploadFileResponse' */
#ifndef SOAP_TYPE_ns1__uploadFileResponse
#define SOAP_TYPE_ns1__uploadFileResponse (26)
#endif

/* ns1__uploadFile has binding name 'ns1__uploadFile' for type 'ns1:uploadFile' */
#ifndef SOAP_TYPE_ns1__uploadFile
#define SOAP_TYPE_ns1__uploadFile (25)
#endif

/* ns1__getBucketNamesResponse has binding name 'ns1__getBucketNamesResponse' for type 'ns1:getBucketNamesResponse' */
#ifndef SOAP_TYPE_ns1__getBucketNamesResponse
#define SOAP_TYPE_ns1__getBucketNamesResponse (24)
#endif

/* ns1__getBucketNames has binding name 'ns1__getBucketNames' for type 'ns1:getBucketNames' */
#ifndef SOAP_TYPE_ns1__getBucketNames
#define SOAP_TYPE_ns1__getBucketNames (23)
#endif

/* ns1__deleteOneFileResponse has binding name 'ns1__deleteOneFileResponse' for type 'ns1:deleteOneFileResponse' */
#ifndef SOAP_TYPE_ns1__deleteOneFileResponse
#define SOAP_TYPE_ns1__deleteOneFileResponse (22)
#endif

/* ns1__deleteOneFile has binding name 'ns1__deleteOneFile' for type 'ns1:deleteOneFile' */
#ifndef SOAP_TYPE_ns1__deleteOneFile
#define SOAP_TYPE_ns1__deleteOneFile (21)
#endif

/* ns1__deleteBucketResponse has binding name 'ns1__deleteBucketResponse' for type 'ns1:deleteBucketResponse' */
#ifndef SOAP_TYPE_ns1__deleteBucketResponse
#define SOAP_TYPE_ns1__deleteBucketResponse (20)
#endif

/* ns1__deleteBucket has binding name 'ns1__deleteBucket' for type 'ns1:deleteBucket' */
#ifndef SOAP_TYPE_ns1__deleteBucket
#define SOAP_TYPE_ns1__deleteBucket (19)
#endif

/* ns1__getFileMessageResponse has binding name 'ns1__getFileMessageResponse' for type 'ns1:getFileMessageResponse' */
#ifndef SOAP_TYPE_ns1__getFileMessageResponse
#define SOAP_TYPE_ns1__getFileMessageResponse (18)
#endif

/* ns1__getFileMessage has binding name 'ns1__getFileMessage' for type 'ns1:getFileMessage' */
#ifndef SOAP_TYPE_ns1__getFileMessage
#define SOAP_TYPE_ns1__getFileMessage (17)
#endif

/* ns1__deleteFileByNameResponse has binding name 'ns1__deleteFileByNameResponse' for type 'ns1:deleteFileByNameResponse' */
#ifndef SOAP_TYPE_ns1__deleteFileByNameResponse
#define SOAP_TYPE_ns1__deleteFileByNameResponse (16)
#endif

/* ns1__deleteFileByName has binding name 'ns1__deleteFileByName' for type 'ns1:deleteFileByName' */
#ifndef SOAP_TYPE_ns1__deleteFileByName
#define SOAP_TYPE_ns1__deleteFileByName (15)
#endif

/* ns1__Exception has binding name 'ns1__Exception' for type 'ns1:Exception' */
#ifndef SOAP_TYPE_ns1__Exception
#define SOAP_TYPE_ns1__Exception (14)
#endif

/* ns1__getFileDetailResponse has binding name 'ns1__getFileDetailResponse' for type 'ns1:getFileDetailResponse' */
#ifndef SOAP_TYPE_ns1__getFileDetailResponse
#define SOAP_TYPE_ns1__getFileDetailResponse (13)
#endif

/* ns1__getFileDetail has binding name 'ns1__getFileDetail' for type 'ns1:getFileDetail' */
#ifndef SOAP_TYPE_ns1__getFileDetail
#define SOAP_TYPE_ns1__getFileDetail (12)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (7)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (108)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (107)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (105)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (104)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (44)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (110)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (109)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (106)
#endif

/* ns1__downLoadFile * has binding name 'PointerTons1__downLoadFile' for type 'ns1:downLoadFile' */
#ifndef SOAP_TYPE_PointerTons1__downLoadFile
#define SOAP_TYPE_PointerTons1__downLoadFile (100)
#endif

/* ns1__uploadFile * has binding name 'PointerTons1__uploadFile' for type 'ns1:uploadFile' */
#ifndef SOAP_TYPE_PointerTons1__uploadFile
#define SOAP_TYPE_PointerTons1__uploadFile (96)
#endif

/* ns1__deleteFileByName * has binding name 'PointerTons1__deleteFileByName' for type 'ns1:deleteFileByName' */
#ifndef SOAP_TYPE_PointerTons1__deleteFileByName
#define SOAP_TYPE_PointerTons1__deleteFileByName (92)
#endif

/* ns1__deleteBatchFile * has binding name 'PointerTons1__deleteBatchFile' for type 'ns1:deleteBatchFile' */
#ifndef SOAP_TYPE_PointerTons1__deleteBatchFile
#define SOAP_TYPE_PointerTons1__deleteBatchFile (88)
#endif

/* ns1__deleteOneFile * has binding name 'PointerTons1__deleteOneFile' for type 'ns1:deleteOneFile' */
#ifndef SOAP_TYPE_PointerTons1__deleteOneFile
#define SOAP_TYPE_PointerTons1__deleteOneFile (84)
#endif

/* ns1__getFileDetail * has binding name 'PointerTons1__getFileDetail' for type 'ns1:getFileDetail' */
#ifndef SOAP_TYPE_PointerTons1__getFileDetail
#define SOAP_TYPE_PointerTons1__getFileDetail (80)
#endif

/* ns1__getFileMessage * has binding name 'PointerTons1__getFileMessage' for type 'ns1:getFileMessage' */
#ifndef SOAP_TYPE_PointerTons1__getFileMessage
#define SOAP_TYPE_PointerTons1__getFileMessage (76)
#endif

/* ns1__doesFileExists * has binding name 'PointerTons1__doesFileExists' for type 'ns1:doesFileExists' */
#ifndef SOAP_TYPE_PointerTons1__doesFileExists
#define SOAP_TYPE_PointerTons1__doesFileExists (72)
#endif

/* ns1__getBucketFileNames * has binding name 'PointerTons1__getBucketFileNames' for type 'ns1:getBucketFileNames' */
#ifndef SOAP_TYPE_PointerTons1__getBucketFileNames
#define SOAP_TYPE_PointerTons1__getBucketFileNames (68)
#endif

/* ns1__getBucketNames * has binding name 'PointerTons1__getBucketNames' for type 'ns1:getBucketNames' */
#ifndef SOAP_TYPE_PointerTons1__getBucketNames
#define SOAP_TYPE_PointerTons1__getBucketNames (64)
#endif

/* ns1__doesBucketExists * has binding name 'PointerTons1__doesBucketExists' for type 'ns1:doesBucketExists' */
#ifndef SOAP_TYPE_PointerTons1__doesBucketExists
#define SOAP_TYPE_PointerTons1__doesBucketExists (60)
#endif

/* ns1__deleteBucket * has binding name 'PointerTons1__deleteBucket' for type 'ns1:deleteBucket' */
#ifndef SOAP_TYPE_PointerTons1__deleteBucket
#define SOAP_TYPE_PointerTons1__deleteBucket (56)
#endif

/* ns1__createBucket * has binding name 'PointerTons1__createBucket' for type 'ns1:createBucket' */
#ifndef SOAP_TYPE_PointerTons1__createBucket
#define SOAP_TYPE_PointerTons1__createBucket (52)
#endif

/* ns1__deleteFiles * has binding name 'PointerTons1__deleteFiles' for type 'ns1:deleteFiles' */
#ifndef SOAP_TYPE_PointerTons1__deleteFiles
#define SOAP_TYPE_PointerTons1__deleteFiles (48)
#endif

/* ns1__Exception * has binding name 'PointerTons1__Exception' for type 'ns1:Exception' */
#ifndef SOAP_TYPE_PointerTons1__Exception
#define SOAP_TYPE_PointerTons1__Exception (45)
#endif

/* xsd__base64Binary * has binding name 'PointerToxsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_PointerToxsd__base64Binary
#define SOAP_TYPE_PointerToxsd__base64Binary (43)
#endif

/* char ** has binding name 'PointerTostring' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostring
#define SOAP_TYPE_PointerTostring (42)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (10)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__deleteFiles(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__deleteFiles *ns1__deleteFiles_, ns1__deleteFilesResponse &ns1__deleteFilesResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__createBucket(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__createBucket *ns1__createBucket_, ns1__createBucketResponse &ns1__createBucketResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__deleteBucket(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__deleteBucket *ns1__deleteBucket_, ns1__deleteBucketResponse &ns1__deleteBucketResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doesBucketExists(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__doesBucketExists *ns1__doesBucketExists_, ns1__doesBucketExistsResponse &ns1__doesBucketExistsResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getBucketNames(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getBucketNames *ns1__getBucketNames_, ns1__getBucketNamesResponse &ns1__getBucketNamesResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getBucketFileNames(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getBucketFileNames *ns1__getBucketFileNames_, ns1__getBucketFileNamesResponse &ns1__getBucketFileNamesResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__doesFileExists(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__doesFileExists *ns1__doesFileExists_, ns1__doesFileExistsResponse &ns1__doesFileExistsResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getFileMessage(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getFileMessage *ns1__getFileMessage_, ns1__getFileMessageResponse &ns1__getFileMessageResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getFileDetail(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getFileDetail *ns1__getFileDetail_, ns1__getFileDetailResponse &ns1__getFileDetailResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__deleteOneFile(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__deleteOneFile *ns1__deleteOneFile_, ns1__deleteOneFileResponse &ns1__deleteOneFileResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__deleteBatchFile(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__deleteBatchFile *ns1__deleteBatchFile_, ns1__deleteBatchFileResponse &ns1__deleteBatchFileResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__deleteFileByName(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__deleteFileByName *ns1__deleteFileByName_, ns1__deleteFileByNameResponse &ns1__deleteFileByNameResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__uploadFile(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__uploadFile *ns1__uploadFile_, ns1__uploadFileResponse &ns1__uploadFileResponse_);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__downLoadFile(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__downLoadFile *ns1__downLoadFile_, ns1__downLoadFileResponse &ns1__downLoadFileResponse_);

/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service operation '__ns1__deleteFiles' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__deleteFiles(struct soap*, ns1__deleteFiles *ns1__deleteFiles_, ns1__deleteFilesResponse &ns1__deleteFilesResponse_);
    /** Web service operation '__ns1__createBucket' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__createBucket(struct soap*, ns1__createBucket *ns1__createBucket_, ns1__createBucketResponse &ns1__createBucketResponse_);
    /** Web service operation '__ns1__deleteBucket' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__deleteBucket(struct soap*, ns1__deleteBucket *ns1__deleteBucket_, ns1__deleteBucketResponse &ns1__deleteBucketResponse_);
    /** Web service operation '__ns1__doesBucketExists' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__doesBucketExists(struct soap*, ns1__doesBucketExists *ns1__doesBucketExists_, ns1__doesBucketExistsResponse &ns1__doesBucketExistsResponse_);
    /** Web service operation '__ns1__getBucketNames' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__getBucketNames(struct soap*, ns1__getBucketNames *ns1__getBucketNames_, ns1__getBucketNamesResponse &ns1__getBucketNamesResponse_);
    /** Web service operation '__ns1__getBucketFileNames' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__getBucketFileNames(struct soap*, ns1__getBucketFileNames *ns1__getBucketFileNames_, ns1__getBucketFileNamesResponse &ns1__getBucketFileNamesResponse_);
    /** Web service operation '__ns1__doesFileExists' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__doesFileExists(struct soap*, ns1__doesFileExists *ns1__doesFileExists_, ns1__doesFileExistsResponse &ns1__doesFileExistsResponse_);
    /** Web service operation '__ns1__getFileMessage' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__getFileMessage(struct soap*, ns1__getFileMessage *ns1__getFileMessage_, ns1__getFileMessageResponse &ns1__getFileMessageResponse_);
    /** Web service operation '__ns1__getFileDetail' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__getFileDetail(struct soap*, ns1__getFileDetail *ns1__getFileDetail_, ns1__getFileDetailResponse &ns1__getFileDetailResponse_);
    /** Web service operation '__ns1__deleteOneFile' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__deleteOneFile(struct soap*, ns1__deleteOneFile *ns1__deleteOneFile_, ns1__deleteOneFileResponse &ns1__deleteOneFileResponse_);
    /** Web service operation '__ns1__deleteBatchFile' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__deleteBatchFile(struct soap*, ns1__deleteBatchFile *ns1__deleteBatchFile_, ns1__deleteBatchFileResponse &ns1__deleteBatchFileResponse_);
    /** Web service operation '__ns1__deleteFileByName' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__deleteFileByName(struct soap*, ns1__deleteFileByName *ns1__deleteFileByName_, ns1__deleteFileByNameResponse &ns1__deleteFileByNameResponse_);
    /** Web service operation '__ns1__uploadFile' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__uploadFile(struct soap*, ns1__uploadFile *ns1__uploadFile_, ns1__uploadFileResponse &ns1__uploadFileResponse_);
    /** Web service operation '__ns1__downLoadFile' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__downLoadFile(struct soap*, ns1__downLoadFile *ns1__downLoadFile_, ns1__downLoadFileResponse &ns1__downLoadFileResponse_);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__deleteFiles(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__createBucket(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__deleteBucket(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__doesBucketExists(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__getBucketNames(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__getBucketFileNames(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__doesFileExists(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__getFileMessage(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__getFileDetail(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__deleteOneFile(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__deleteBatchFile(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__deleteFileByName(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__uploadFile(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__downLoadFile(struct soap*);

#endif

/* End of soapStub.h */
