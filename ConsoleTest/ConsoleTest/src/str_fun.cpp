#include "stdafx.h"
#include "str_fun.h"
#include <windows.h>


std::string Utf8ToGbk(const char *src_str)
{
    int len = MultiByteToWideChar(CP_UTF8, 0, src_str, -1, NULL, 0);
    wchar_t* wszGBK = new wchar_t[len + 1];
    memset(wszGBK, 0, sizeof(wchar_t) * (len + 1));
    MultiByteToWideChar(CP_UTF8, 0, src_str, -1, wszGBK, len);
    len = WideCharToMultiByte(CP_ACP, 0, wszGBK, -1, NULL, 0, NULL, NULL);
    char* szGBK = new char[len + 1];
    memset(szGBK, 0, len + 1);
    WideCharToMultiByte(CP_ACP, 0, wszGBK, -1, szGBK, len, NULL, NULL);
    std::string strTemp(szGBK);
    if (wszGBK)
        delete[] wszGBK;
    if (szGBK)
        delete[] szGBK;
    return strTemp;
}


int str_compare(char *str1, char *str2)
{
	int ret = 0;
	while (*str1 != 0 && *str2 != 0)
	{
		ret = *str1++ - *str2++;
		if (ret != 0)
			return ret;
	}
	if (*str1 == 0 && *str2 == 0)
		return 0;
	else if (*str1 == 0)
		return *str2;
	else
		return *str1;
}


/* //  *用str替换指定字符串从起始位置pos开始长度为len的字符串  
    //  *string& replace(size_t pos, size_t len, const string& str);
'\' 或 ' 前面补1个'\',防止有\ ' 导致插入数据库错误
*/
int str_replace(char str[], int size, int strlenth)
{
	if (strchr(str, 39) == nullptr && strchr(str, 34) == nullptr && strchr(str, 92) == nullptr)  //  '\'92  '39 "34
		return 0;
	int i = 0, j = 0;
	int free_space = 0;  //str 中的空闲空间
	vector<int> index;
	for (i = 0; i < strlenth; i++)
	{
		if (str[i] == '\'' || str[i] == '\\' || str[i] == '\"')
		{
			index.push_back(i);
		}
	}
	free_space = size - strlenth - 1;
	int npos = (int)index.size();     //计算出 \ ' 的数量，每个位置补1个'\'
	if (npos - free_space > 0)
	{
		printf("字符串空间不足，替换字符失败！");
		return -1;
	}
	index.push_back(strlenth + 1);     //从字符串末尾开始移位
									   //从最后开始往后移位，只遍历一次
	while (npos >= 1)
	{
		for (j = index[npos] - 1; j >= index[npos - 1]; j--)
			str[j + npos] = str[j];
		str[index[npos - 1] + npos - 1] = '\\';

		npos--;
	}
	return 0;
}

char *strRemoveBlank(char *str)
{
	int nlen = strlen(str);
	int nCountBlank = 0;
	for (int i = 0; i < nlen; i++)
	{
		if (*(str + i) != ' ')
		{
			nCountBlank = 0;
			continue;
		}
		nCountBlank++;
		if (nCountBlank >= 2)
		{
			int j = 0;
			for (j = i; j < nlen; j++)
			{
				*(str + j) = *(str + j + 1);
			}
			i--;
		}
	}

	return str;
}
/*
 *从字符串src中删除字符串str
 */
int strDel(char *src, char *str)
{
    char *pos = src;
    vector<char *> index;
    for (; pos != NULL; pos += strlen(str))   // 首先获取全部位置
    {
        pos = strstr(pos, str);
        if (pos == NULL)
            break;
        index.push_back(pos);
    }
    int len = strlen(src);

    for (int n = index.size() - 1; n >= 0; n--) // 从最后一个位置开始移动
        for (char *tmp = index[n]; tmp < src + len - 1; tmp++)
            *tmp = *(tmp + strlen(str));
    return 0;
}
/*
从字符串中获取不包含重复字符的最大子串
*/
string maxSubStr(string str)
{
    string substr;
    unsigned int maxLen = 0;
    std::unordered_map<char, int> indexMap;
    int posBegin = 0;
    int lastBegin = 0;
    for (unsigned int i = 0; i < str.length(); )
    {
        auto iter = indexMap.find(str.at(i));
        if (iter != indexMap.end())    // found replicate char
        {
            if (maxLen < i - posBegin)
            {
                substr = str.substr(posBegin, i - posBegin);
                maxLen = i - posBegin;
            }
            lastBegin = posBegin;
            posBegin = iter->second + 1;
            
            // remove elements before posBegin in map 
            for (int tmp = lastBegin; tmp < posBegin; tmp++)
            {
                auto it = indexMap.find(str.at(tmp));
                if(it != indexMap.end())
                    indexMap.erase(indexMap.find(str.at(tmp)));
            }
        }
        else
        {
            indexMap.insert(std::pair<char, int>(str.at(i), i));
            i++;
        }
    }
    if (maxLen < str.length() - posBegin)
    {
        substr = str.substr(posBegin, str.length() - posBegin);
        maxLen = str.length() - posBegin;
    }
    return substr;
}